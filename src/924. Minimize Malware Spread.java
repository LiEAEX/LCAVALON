class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial); 
        ArrayList<Integer> init = new ArrayList<>();
        for (int a : initial){
            init.add(a);
        }

        int max = 0; //max count for an union in the graph
        int res = initial[0];
        for(int i : initial){
            boolean[] containsOtherMal = new boolean[1];//use an array to contain the flag - whether the union has another malware
            Set<Integer> visited = new HashSet<>();
            int count = dfs(i, i, graph, visited, containsOtherMal, init); //how many nodes in the current union
            if(containsOtherMal[0]){//if current union has another malware, which means if we delete current node, still another malware will affect the whole union
                continue;
            }
            if(count > max){
                max = count;
                res = i;
            }
        }
        return res;
    }
    
    //dfs to count how many node in current union begin from start
    int dfs(int start, int initialStart, int[][] graph, Set<Integer> visited, boolean[] containsOtherMal, ArrayList<Integer> init){
        if(visited.contains(start) || containsOtherMal[0]){ 
            return 0;
        }
        int res = 1;
        visited.add(start);
        for(int i = 0; i < graph[start].length; i ++){
            if(graph[start][i] == 1){
                if(initialStart != i && init.contains(i)){//if we found another malware that is different from the initialStart, we set the flag to true and there is no need to continue the search.
                    containsOtherMal[0] = true;
                    break;
                }
                res += dfs(i, initialStart, graph, visited, containsOtherMal, init);
            }
        }
        return res;
    }
}


class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial); 
        ArrayList<Integer> init = new ArrayList<>();
        for (int a : initial){
            init.add(a);
        }

        int max = 0; //max count for an union in the graph
        int res = initial[0];
        for(int i : initial){
            boolean[] containsOtherMal = new boolean[1];//use an array to contain the flag - whether the union has another malware
            Set<Integer> visited = new HashSet<>();
            int count = dfs(i, i, graph, visited, containsOtherMal, init); //how many nodes in the current union
            if(containsOtherMal[0]){// when current union has another malware
                continue;
            }
            if(count > max){
                max = count;
                res = i;
            }
        }
        return res;
    }
    
    //dfs to count how many node in current union begin from start
    int dfs(int start, int initialStart, int[][] graph, Set<Integer> visited, boolean[] containsOtherMal, ArrayList<Integer> init){
        if(visited.contains(start) || containsOtherMal[0]){ 
            return 0;
        }
        int res = 1;
        visited.add(start);
        for(int i = 0; i < graph[start].length; i ++){
            if(graph[start][i] == 1){
                if(initialStart != i && init.contains(i)){
                    containsOtherMal[0] = true;
                    break;
                }
                res += dfs(i, initialStart, graph, visited, containsOtherMal, init);
            }
        }
        return res;
    }
}